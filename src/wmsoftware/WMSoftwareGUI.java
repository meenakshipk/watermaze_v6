/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package wmsoftware;

import ij.io.FileSaver;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.OvalRoi;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.gui.Roi;
import ij.measure.CurveFitter;
import ij.measure.Measurements;
import ij.measure.ResultsTable;
import ij.plugin.ZProjector;
import ij.process.FloatProcessor;
import ij.process.ImageProcessor;
import ij.plugin.filter.*;
import ij.plugin.frame.RoiManager;
import ij.process.Blitter;
import java.awt.Component;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Serializable;
import static java.lang.Float.NaN;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.NoSuchElementException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Meenakshi
 */
public class WMSoftwareGUI extends javax.swing.JFrame {

    private int totalMiceNo;
    private int totalTrialNo;
    private DataStore dss;
    private File dir;
    private Component frame;
    private double userBin;
    private int dimX = 240;
    private int dimY = 240;
    private int pX = 175;
    private int pY = 175;

    /**
     * Creates new form WMSoftwareGUI
     */
    public WMSoftwareGUI() {
        initComponents();
        jComboBoxTrialNo.removeAllItems();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jLabel3 = new javax.swing.JLabel();
        buttonGroupPlotGroupDataBy = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldTrials = new javax.swing.JTextField();
        jTextFieldTotalMiceNo = new javax.swing.JTextField();
        jButtonSelectFiles = new javax.swing.JButton();
        jComboBoxTrialNo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jButtonUploadFiles = new javax.swing.JButton();
        jButtonReadFiles = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabelMaps = new javax.swing.JLabel();
        jCheckBoxRDist = new javax.swing.JCheckBox();
        jCheckBoxRVel = new javax.swing.JCheckBox();
        jCheckBoxRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRVelErr = new javax.swing.JCheckBox();
        jButtonCalculateMeasures = new javax.swing.JButton();
        jCheckBoxResTime = new javax.swing.JCheckBox();
        jCheckBoxASCIIvector = new javax.swing.JCheckBox();
        jLabelMaps1 = new javax.swing.JLabel();
        jCheckBoxDivergence = new javax.swing.JCheckBox();
        jCheckBoxCurl = new javax.swing.JCheckBox();
        jCheckBoxGradient = new javax.swing.JCheckBox();
        jButtonGenerateMaps = new javax.swing.JButton();
        jCheckBoxAverageMouseMap = new javax.swing.JCheckBox();
        jCheckBoxHeatMap = new javax.swing.JCheckBox();
        jProgressBar = new javax.swing.JProgressBar();
        jLabel6 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jCheckBoxRDistvRVel = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelErr = new javax.swing.JCheckBox();
        jLabelPlots = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jTextFieldUserBin = new javax.swing.JTextField();
        jButtonGeneratePlots = new javax.swing.JButton();
        jCheckBoxAverageMousePlot = new javax.swing.JCheckBox();

        jDialog1.setTitle("Select files");
        jDialog1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jDialog1.setModalityType(java.awt.Dialog.ModalityType.DOCUMENT_MODAL);

        jLabel3.setText("Select files for each trial:");

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(jLabel3)
                .addContainerGap(259, Short.MAX_VALUE))
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(jLabel3)
                .addContainerGap(260, Short.MAX_VALUE))
        );

        jDialog1.getAccessibleContext().setAccessibleParent(jButtonSelectFiles);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Water Maze Software");

        jLabel1.setText("Number of mice per trial:");

        jLabel2.setText("Total number of trials:");

        jButtonSelectFiles.setText("Select Files");
        jButtonSelectFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSelectFilesActionPerformed(evt);
            }
        });

        jComboBoxTrialNo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel4.setText("Trial number:");

        jButtonUploadFiles.setText("Upload Files");
        jButtonUploadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonUploadFilesActionPerformed(evt);
            }
        });

        jButtonReadFiles.setText("Read Files");
        jButtonReadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonReadFilesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jTextFieldTrials, javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jButtonSelectFiles, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonUploadFiles)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonReadFiles)
                        .addGap(0, 287, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextFieldTrials, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButtonSelectFiles)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonUploadFiles)
                    .addComponent(jButtonReadFiles))
                .addContainerGap(184, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Select Files", jPanel1);

        jLabelMaps.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps.setText("Measures:");

        jCheckBoxRDist.setText("Displacement");

        jCheckBoxRVel.setText("Velocity");

        jCheckBoxRVelaP.setText("Velocity along platform");

        jCheckBoxRVelpP.setText("Velocity perpendicular to platform");

        jCheckBoxRVelErr.setText("Velocity Error");

        jButtonCalculateMeasures.setText("Calculate");
        jButtonCalculateMeasures.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCalculateMeasuresActionPerformed(evt);
            }
        });

        jCheckBoxResTime.setText("Residence Time");

        jCheckBoxASCIIvector.setText("Vector map");

        jLabelMaps1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps1.setText("Maps:");

        jCheckBoxDivergence.setText("Divergence map");

        jCheckBoxCurl.setText("Curl map");

        jCheckBoxGradient.setText("Gradient map");

        jButtonGenerateMaps.setText("Generate Maps");
        jButtonGenerateMaps.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGenerateMapsActionPerformed(evt);
            }
        });

        jCheckBoxAverageMouseMap.setText("Average Mouse");

        jCheckBoxHeatMap.setText("Heat map");

        jLabel6.setText("Progress Bar:");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jProgressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jCheckBoxResTime)
                                    .addComponent(jLabelMaps)
                                    .addComponent(jCheckBoxRDist)
                                    .addComponent(jCheckBoxRVelpP)
                                    .addComponent(jCheckBoxRVel)
                                    .addComponent(jCheckBoxRVelaP)
                                    .addComponent(jButtonCalculateMeasures)
                                    .addComponent(jCheckBoxRVelErr))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)
                                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jCheckBoxAverageMouseMap)
                                    .addComponent(jCheckBoxASCIIvector)
                                    .addComponent(jLabelMaps1)
                                    .addComponent(jCheckBoxGradient)
                                    .addComponent(jCheckBoxDivergence)
                                    .addComponent(jCheckBoxCurl)
                                    .addComponent(jButtonGenerateMaps)
                                    .addComponent(jCheckBoxHeatMap))))
                        .addGap(292, 292, 292))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel6)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxResTime)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRDist)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelaP)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelpP))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxASCIIvector)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxDivergence)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxCurl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxHeatMap)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxGradient)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVelErr)
                .addGap(12, 12, 12)
                .addComponent(jCheckBoxAverageMouseMap)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButtonCalculateMeasures)
                    .addComponent(jButtonGenerateMaps))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 25, Short.MAX_VALUE)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jTabbedPane1.addTab("Generate Maps", jPanel2);

        jCheckBoxRDistvRVel.setText("R-Distance vs R-Velocity");

        jCheckBoxRDistvRVelaP.setText("R-Distance vs R-Velocity along platform");

        jCheckBoxRDistvRVelpP.setText("R-Distance vs R-Velocity perpendicular to platform");

        jCheckBoxRDistvRVelErr.setText("R-Distance vs R-Velocity Errors");

        jLabelPlots.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelPlots.setText("Plots:");

        jLabel5.setText("Enter bin width in X:");

        jTextFieldUserBin.setText("0.00");

        jButtonGeneratePlots.setText("Generate Plots");
        jButtonGeneratePlots.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGeneratePlotsActionPerformed(evt);
            }
        });

        jCheckBoxAverageMousePlot.setText("Average Mouse");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxAverageMousePlot)
                    .addComponent(jLabelPlots)
                    .addComponent(jCheckBoxRDistvRVelErr)
                    .addComponent(jCheckBoxRDistvRVelpP)
                    .addComponent(jCheckBoxRDistvRVelaP)
                    .addComponent(jCheckBoxRDistvRVel)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(325, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jButtonGeneratePlots)
                .addGap(0, 499, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelPlots)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelaP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelpP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelErr)
                .addGap(17, 17, 17)
                .addComponent(jCheckBoxAverageMousePlot)
                .addGap(18, 18, 18)
                .addComponent(jButtonGeneratePlots)
                .addContainerGap(69, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Plots", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCalculateMeasuresActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCalculateMeasuresActionPerformed
        String taskLog = "";
        ArrayList<HashMap<String, Object>>[] data = dss.getInputData();
        //loop through trials
        for (int trial = 0; trial < dss.getTotalTrials(); trial++) {
            ArrayList<HashMap<String, Object>> trialData = data[trial];
            //loop through mice
            for (int mouse = 0; mouse < dss.getTotalMice(); mouse++) {
                HashMap<String, Object> mouseData = trialData.get(mouse);
                DataTrace_ver1 series = (DataTrace_ver1) mouseData.get("Position");
                Object result = null;
                if (jCheckBoxResTime.isSelected()) {
                    ArrayList<Double> resTimeArray = this.residenceTime(series);
                    ImageProcessor ipResTime = new FloatProcessor(dimX, dimY);
                    float[][] arrayResTime = new float[dimX][dimY];
                    for (int Y = 0; Y < dimY; Y++) {
                        for (int X = 0; X < dimX; X++) {
                            int arrayIdx = (Y * dimX) + X;
                            arrayResTime[X][Y] = resTimeArray.get(arrayIdx).floatValue();
                        }
                    }
                    ipResTime.setFloatArray(arrayResTime);
                    result = ipResTime;
                    mouseData.put("Residence Time", result);
                }
                if (jCheckBoxRDist.isSelected()) {
                    result = this.displacementVector(series);
                    mouseData.put("Displacement", result);
                }
                if (jCheckBoxRVel.isSelected()) {
                    result = this.velocityVector(series);
                    mouseData.put("Velocity", result);
                }
                if (jCheckBoxRVelaP.isSelected()) {
                    result = this.velocityAlongPt(series);
                    mouseData.put("Velocity along platform", result);
                }
                if (jCheckBoxRVelpP.isSelected()) {
                    result = this.velocityPerpendicularPt(series);
                    mouseData.put("Velocity perpendicular platform", result);
                }
                if (jCheckBoxRVelErr.isSelected()) {
                    result = this.velocityErrorVector(series);
                    mouseData.put("Velocity error", result);
                }
                trialData.set(mouse, mouseData);
            }
            data[trial] = trialData;
        }
        //Select directory to store files when generating maps/plots/ascii origin files
        JFileChooser Fc = new JFileChooser();
        Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        Fc.showOpenDialog(this);
        dir = Fc.getSelectedFile();

        if (!taskLog.isEmpty()) {
            JOptionPane.showMessageDialog(frame, "Task completed with the following errors:\n" + taskLog, "Task Completed with Error.", JOptionPane.WARNING_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(frame, "Task completed.\n" + taskLog, "Task Completed", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_jButtonCalculateMeasuresActionPerformed

    private void jButtonReadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonReadFilesActionPerformed
        //reads the file and creates DataTrace for each file/mouse, in each trial, and stores it in the hashmap specific for the mouse
        dss.readFile();
        //print dialog box
        JOptionPane.showMessageDialog(frame, "Files read.", "Task completed", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jButtonReadFilesActionPerformed

    private void jButtonUploadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonUploadFilesActionPerformed
        //choose multiple files
        JFileChooser Fc = new JFileChooser();
        Fc.setMultiSelectionEnabled(true);
        Fc.showOpenDialog(this);
        int trial = jComboBoxTrialNo.getSelectedIndex();
        if (totalMiceNo != Fc.getSelectedFiles().length) {
            JOptionPane.showMessageDialog(frame, "Number of files selected does not match number of mice.", "ERROR", JOptionPane.ERROR_MESSAGE);
        } else {
            //update DataStore
            ArrayList<HashMap<String, Object>>[] data = dss.getInputData();
            ArrayList<HashMap<String, Object>> trialData = data[trial];
            File[] files = Fc.getSelectedFiles();
            for (int mouse = 0; mouse < totalMiceNo; mouse++) {
                HashMap<String, Object> mouseData = new HashMap<>();
                mouseData.put("File", files[mouse]);
                mouseData.put("File Name", files[mouse].getName());
                trialData.set(mouse, mouseData);
            }
        }
    }//GEN-LAST:event_jButtonUploadFilesActionPerformed

    private void jButtonSelectFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSelectFilesActionPerformed
        jComboBoxTrialNo.removeAllItems();
        try {
            totalTrialNo = Integer.parseInt(jTextFieldTrials.getText());
            totalMiceNo = Integer.parseInt(jTextFieldTotalMiceNo.getText());
            if (totalTrialNo == 0 || totalMiceNo == 0) {
                JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
                return;
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
            return;
        }
        //create checkbox with total trial no.
        for (int i = 0; i < totalTrialNo; i++) {
            jComboBoxTrialNo.addItem(Integer.toString(i + 1));
        }
        //create dataStore
        dss = new DataStore(totalTrialNo, totalMiceNo);
    }//GEN-LAST:event_jButtonSelectFilesActionPerformed

    private void jButtonGenerateMapsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGenerateMapsActionPerformed
        String taskLog = "";
        if (dir == null) {
            JOptionPane.showMessageDialog(frame, "Please select directory to save plots.", "ERROR", JOptionPane.ERROR_MESSAGE);
            //Select directory to store files
            JFileChooser Fc = new JFileChooser();
            Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            Fc.showOpenDialog(this);
            dir = Fc.getSelectedFile();
        }
        //BitSet for measures
        BitSet bs = new BitSet(6);
        bs.set(0, jCheckBoxRDist.isSelected());
        bs.set(1, jCheckBoxRVel.isSelected());
        bs.set(2, jCheckBoxRVelaP.isSelected());
        bs.set(3, jCheckBoxRVelpP.isSelected());
        bs.set(4, jCheckBoxRVelErr.isSelected());
//        bs.set(5, jCheckBoxResTime.isSelected());

        //BitSet for user selected output file type
        BitSet bs2 = new BitSet(5);
        bs2.set(0, jCheckBoxASCIIvector.isSelected());
        bs2.set(1, jCheckBoxDivergence.isSelected());
        bs2.set(2, jCheckBoxCurl.isSelected());
        bs2.set(3, jCheckBoxHeatMap.isSelected());
        bs2.set(4, jCheckBoxGradient.isSelected());

        ArrayList<HashMap<String, Object>>[] data = dss.getInputData();
        //TO DO - save images as stack       ImageStack resultStack = new ImageStack(dimX, dimY);
        //loop measure selection
        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
            String resultName = "";
            switch (i) {
                case 0: //rdis
                    resultName = "Displacement";
                    break;

                case 1: //rvel
                    resultName = "Velocity";
                    break;

                case 2: //rvel along pt
                    resultName = "Velocity along platform";
                    break;

                case 3://rvel p pt
                    resultName = "Velocity perpendicular platform";
                    break;

                case 4://vel err
                    resultName = "Velocity error";
                    break;
//                        case 5: //restime
//                            resultName = "Residence Time";
//                            break;
            }
            File saveDir = null;
            for (int trial = 0; trial < dss.getTotalTrials(); trial++) {
                ArrayList<HashMap<String, Object>> trialData = data[trial];

                //individual mouse
                //loop through mice
                for (int mouse = 0; mouse < dss.getTotalMice(); mouse++) {
                    HashMap<String, Object> mouseData = trialData.get(mouse);
                    ImageProcessor ipResTime = (ImageProcessor) mouseData.get("Residence Time");
                    DataTrace_ver1 position = (DataTrace_ver1) mouseData.get("Position");

                    DataTrace_ver1 measure = (DataTrace_ver1) mouseData.get(resultName);
                    ImagePlus xImage = null, yImage = null, image = null;
                    ImagePlus result = null;
                    String output = "";
                    double[] Rm = new double[2];
                    if (!bs2.get(0, 3).isEmpty()) {
                        //for vector map, div and curl
                        //create sumPixels image
                        ImageProcessor xImageIp = this.sumPixelsImage(position, measure.getX());
                        ImageProcessor yImageIp = this.sumPixelsImage(position, measure.getY());
                        //ResTime weighted
                        xImage = this.resTimeWeightedMap(ipResTime, xImageIp);
                        yImage = this.resTimeWeightedMap(ipResTime, yImageIp);
                        //define bounds for resizing image after processing?

                    }
                    if (!bs2.get(3, 5).isEmpty()) {
                        //for heat map and gradient
                        //create sumPixels image
                        ArrayList<Double> rMeasure = this.vectorMagnitude(measure);
                        ImageProcessor imageIp = this.sumPixelsImage(position, rMeasure);
                        //restime weighted
                        image = this.resTimeWeightedMap(ipResTime, imageIp);
                    }
                    //loop output type
                    for (int j = bs2.nextSetBit(0); j >= 0; j = bs2.nextSetBit(j + 1)) {
                        switch (j) {
                            case 0:
                                //write vector measure into an ascii file
                                output = "vector";
                                result = this.vectorMap(xImage, yImage, resultName);
                                break;
                            case 1: //Divergence
                                output = "divergence";
                                xImage = this.thresholdedSurfaceFit3(xImage);
                                yImage = this.thresholdedSurfaceFit3(yImage);
                                ImageProcessor div = this.divergence(xImage, yImage).getProcessor();
                                Rm = this.RmFromMap(ipResTime, div);
                                result = this.resizeImage(ipResTime, div);
                                break;
                            case 2: //Curl
                                output = "curl";
                                xImage = this.thresholdedSurfaceFit3(xImage);
                                yImage = this.thresholdedSurfaceFit3(yImage);
                                ImageProcessor curl = this.curl(xImage, yImage).getProcessor();
                                Rm = this.RmFromMap(ipResTime, curl);
                                result = this.resizeImage(ipResTime, curl);
                                break;
                            case 3: //Gradient
                                output = "gradient";
                                ImagePlus image2 = this.thresholdedSurfaceFit3(image);
                                ImageProcessor grad = this.gradient(image2).getProcessor();
                                Rm = this.RmFromMap(ipResTime, grad);
                                result = this.resizeImage(ipResTime, grad);
                                break;
                            case 4: //Heat map
                                output = "heatmap";
                                //pixels not sampled are set to NaN
                                Roi selectionROI = image.getRoi();
                                image.getProcessor().setColor(Float.NaN);
                                image.getProcessor().fillOutside(selectionROI);
                                result = image;
                                break;
                        }
                        //save imageplus
                        String fileName = resultName + "_" + output + "_T" + trial + "_M" + mouse;
                        result.setTitle(fileName);
                        try {
                            saveDir = new File(dir.getPath() + File.separator + resultName);
                            saveDir.mkdir();
                            new FileSaver(result).saveAsTiff(saveDir + File.separator + result.getTitle() + ".tif");
                        } catch (Exception e) {
                            System.out.println("Error saving" + fileName + "file.");
                            System.out.println(e);
                            taskLog += "Error saving" + fileName + "files.\n";
                            System.out.println();
                        }
                        if (j != 0) {
                            //store Rm
                            mouseData.put(resultName + "_" + output + "_maxRm", (float) Rm[0]);
                            mouseData.put(resultName + "_" + output + "_minRm", (float) Rm[1]);
                            //calculate and store quadZoneIntensity
                            float[] quadZoneValues = this.quadrantandZoneMeasures(result);
                            for (int q = 0; q < 4; q++) {
                                mouseData.put(resultName + "_" + output + "_Q" + q, quadZoneValues[q]);
                                mouseData.put(resultName + "_" + output + "_P" + q, quadZoneValues[q + 4]);
                                //trialData.set(mouse, mouseData);
                            }
                        }
                        if (j == Integer.MAX_VALUE) {
                            break;
                        }
                    }
//                    trialData.set(mouse, mouseData);
                }

                //average mouse
                if (jCheckBoxAverageMouseMap.isSelected()) {
                    //loop through mice
                    ImagePlus result = null;
                    String output = "";
                    double[] Rm = new double[2];
                    ImageStack resTimeStack = new ImageStack(dimX, dimY), xImgStack = new ImageStack(dimX, dimY), yImgStack = new ImageStack(dimX, dimY), imgStack = new ImageStack(dimX, dimY);

                    for (int mouse = 0; mouse < dss.getTotalMice(); mouse++) {
                        HashMap<String, Object> mouseData = trialData.get(mouse);
                        DataTrace_ver1 position = (DataTrace_ver1) mouseData.get("Position");
                        DataTrace_ver1 measure = (DataTrace_ver1) mouseData.get(resultName);

                        ImageProcessor ipResTime = (ImageProcessor) mouseData.get("Residence Time");
                        resTimeStack.addSlice(ipResTime);

                        if (!bs2.get(0, 3).isEmpty()) {
                            //for vector map, div and curl
                            //create sumPixels image
                            ImageProcessor xImageIp = this.sumPixelsImage(position, measure.getX());
                            xImgStack.addSlice(xImageIp);
                            ImageProcessor yImageIp = this.sumPixelsImage(position, measure.getY());
                            yImgStack.addSlice(yImageIp);
                        }
                        if (!bs2.get(3, 5).isEmpty()) {
                            //for heat map and gradient
                            //create sumPixels image
                            ArrayList<Double> rMeasure = this.vectorMagnitude(measure);
                            ImageProcessor imageIp = this.sumPixelsImage(position, rMeasure);
                            imgStack.addSlice(imageIp);
                        }
                    }
                    ImagePlus aveXImage = null, aveYImage = null, aveImage = null;
                    ImagePlus aveResTime = new ImagePlus("ResTime_" + output + "_T" + trial, resTimeStack);
                    aveResTime = ZProjector.run(aveResTime, "sum");
                    if (!bs2.get(0, 3).isEmpty()) {
                        ImagePlus xImgStackImp = new ImagePlus("xImg_" + resultName + "_" + output + "_T" + trial, xImgStack);
                        ImagePlus yImgStackImp = new ImagePlus("yImg_" + resultName + "_" + output + "_T" + trial, yImgStack);
                        aveXImage = ZProjector.run(xImgStackImp, "sum");
                        aveYImage = ZProjector.run(yImgStackImp, "sum");
                        //restime weighted
                        aveXImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveXImage.getProcessor());
                        aveYImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveYImage.getProcessor());
                    }
                    if (!bs2.get(3, 5).isEmpty()) {
                        ImagePlus imgStackImp = new ImagePlus("img_" + resultName + "_" + output + "_T" + trial, imgStack);
                        aveImage = ZProjector.run(imgStackImp, "sum");
                        //restime weighted
                        aveImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveImage.getProcessor());
                    }

                    HashMap<String, Object> mouseData = trialData.get(dss.getTotalMice());
                    //loop output type
                    for (int j = bs2.nextSetBit(0); j >= 0; j = bs2.nextSetBit(j + 1)) {
                        switch (j) {
                            case 0:
                                //write vector measure into an ascii file
                                output = "vector";
                                result = this.vectorMap(aveXImage, aveYImage, resultName);
                                break;
                            case 1: //Divergence
                                output = "divergence";
                                aveXImage = this.thresholdedSurfaceFit3(aveXImage);
                                aveYImage = this.thresholdedSurfaceFit3(aveYImage);
                                ImageProcessor div = this.divergence(aveXImage, aveYImage).getProcessor();
                                Rm = this.RmFromMap(aveResTime.getProcessor(), div);
                                result = this.resizeImage(aveResTime.getProcessor(), div);
                                break;
                            case 2: //Curl
                                output = "curl";
                                aveXImage = this.thresholdedSurfaceFit3(aveXImage);
                                aveYImage = this.thresholdedSurfaceFit3(aveYImage);
                                ImageProcessor curl = this.curl(aveXImage, aveYImage).getProcessor();
                                Rm = this.RmFromMap(aveResTime.getProcessor(), curl);
                                result = this.resizeImage(aveResTime.getProcessor(), curl);
                                break;
                            case 3: //Gradient
                                output = "gradient";
                                ImagePlus aveImage2 = this.thresholdedSurfaceFit3(aveImage);
                                ImageProcessor grad = this.gradient(aveImage2).getProcessor();
                                Rm = this.RmFromMap(aveResTime.getProcessor(), grad);
                                result = this.resizeImage(aveResTime.getProcessor(), grad);
                                break;
                            case 4: //hm
                                output = "heatmap";
                                Roi selectionROI = aveImage.getRoi();
                                aveImage.getProcessor().setColor(Float.NaN);
                                aveImage.getProcessor().fillOutside(selectionROI);
                                result = aveImage;
                                break;
                        }
                        //save imageplus
                        String fileName = resultName + "_" + output + "_T" + trial + "_AveM";
                        result.setTitle(fileName);
                        try {
                            new FileSaver(result).saveAsTiff(saveDir.getPath() + File.separator + result.getTitle() + ".tif");
                        } catch (Exception e) {
                            System.out.println("Error saving" + fileName + "file.");
                            System.out.println(e);
                            taskLog += "Error saving" + fileName + "files.\n";
                            System.out.println();
                        }
                        if (j != 0) {
                            //store Rm
                            mouseData.put(resultName + "_" + output + "_maxRm", (float) Rm[0]);
                            mouseData.put(resultName + "_" + output + "_minRm", (float) Rm[1]);
                            //calculate and store quadZoneIntensity
                            float[] quadZoneValues = this.quadrantandZoneMeasures(result);
                            for (int q = 0; q < 4; q++) {
                                mouseData.put(resultName + "_" + output + "_Q" + q, quadZoneValues[q]);
                                mouseData.put(resultName + "_" + output + "_P" + q, quadZoneValues[q + 4]);
                                //trialData.set(mouse, mouseData);
                            }
                        }
                        if (j == Integer.MAX_VALUE) {
                            break;
                        }
                    }
//                    trialData.set(dss.getTotalMice(), mouseData);
                }
//                data[trial] = trialData;
            }

            String output = "";
            for (int j = bs2.nextSetBit(1); j >= 0; j = bs2.nextSetBit(j + 1)) {
                switch (j) {
                    case 1:
                        output = "divergence";
                        break;
                    case 2:
                        output = "curl";
                        break;
                    case 3:
                        output = "heatmap";
                        break;
                    case 4:
                        output = "gradient";
                        break;
                }
                try {
                    File Rm = new File(dir.getPath() + File.separator + "RmMap");
                    dss.writeFile(resultName, output, "_maxRm", Rm);
                    dss.writeFile(resultName, output, "_minRm", Rm);
                } catch (Exception e) {
                    System.out.println("Error occured while writing RmMap " + resultName + " " + output + " values into a file.");
                    System.out.println(e);
                    taskLog += "Error occured while writing RmMap values into a file.\n";
                }
                try {
                    File quadZone = new File(dir.getPath() + File.separator + "quadrantMeasure");
                    for (int q = 0; q < 4; q++) {
                        dss.writeFile(resultName, output, "_Q" + q, quadZone);
                        dss.writeFile(resultName, output, "_P" + q, quadZone);
                    }
                } catch (Exception e) {
                    System.out.println("Error occured while writing Rm values into a file.");
                    System.out.println(e);
                    taskLog += "Error occured while writing Rm values into a file.\n";
                }
                if (j == Integer.MAX_VALUE) {
                    break;
                }
            }
            if (i == Integer.MAX_VALUE) {
                break;
            }
        }
        if (!taskLog.isEmpty()) {
            JOptionPane.showMessageDialog(frame, "Task completed with the following errors:\n" + taskLog, "Task Completed with Error.", JOptionPane.WARNING_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(frame, "Task completed.\n" + taskLog, "Task Completed", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_jButtonGenerateMapsActionPerformed

    private void jButtonGeneratePlotsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGeneratePlotsActionPerformed
        String taskLog = "";
        if (dir == null) {
            JOptionPane.showMessageDialog(frame, "Please select directory to save plots.", "ERROR", JOptionPane.ERROR_MESSAGE);
            //Select directory to store files
            JFileChooser Fc = new JFileChooser();
            Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            Fc.showOpenDialog(this);
            dir = Fc.getSelectedFile();
        }

        //bitset for user selection of distvmeasure plot
        BitSet bs = new BitSet(4);
        bs.set(0, jCheckBoxRDistvRVel.isSelected());
        bs.set(1, jCheckBoxRDistvRVelaP.isSelected());
        bs.set(2, jCheckBoxRDistvRVelpP.isSelected());
        bs.set(3, jCheckBoxRDistvRVelErr.isSelected());

        //file to store all Rm values calculated from fit
        File Rm = new File(dir.getPath() + File.separator + "RmPlot");
        //bin size for binning values
        userBin = Double.parseDouble(jTextFieldUserBin.getText());
        //loop through user selections
        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
            String resultName = "";
            switch (i) {
                case 0: //rvel
                    resultName = "Velocity";
                    break;

                case 1: //rvel along pt
                    resultName = "Velocity along platform";
                    break;

                case 2://rvel p pt
                    resultName = "Velocity perpendicular platform";
                    break;

                case 3://vel err
                    resultName = "Velocity error";
                    break;
            }
            ArrayList<HashMap<String, Object>>[] data = dss.getInputData();
            for (int trial = 0; trial < dss.getTotalTrials(); trial++) {
                ArrayList<HashMap<String, Object>> trialData = data[trial];
                //individual mouse
                //loop through mice
                for (int mouse = 0; mouse < dss.getTotalMice(); mouse++) {
                    HashMap<String, Object> mouseData = trialData.get(mouse);
                    String title = "Distance vs R" + resultName + "_M" + mouse;
                    DataTrace_ver1 DispDt = null, resultDt = null;
                    try {
                        DispDt = (DataTrace_ver1) mouseData.get("Displacement");
                        resultDt = (DataTrace_ver1) mouseData.get(resultName);
                        //calculate r-distance and r-measure
                        ArrayList<Object> result = this.RmFromPolynomialFit(DispDt, resultDt);
                        //decorate and save plot
                        Plot plot = (Plot) result.get(1);
                        plot.setXYLabels("Distance", resultName);
                        //PlotWindow pw = plot.show();
                        //pw.setTitle(title);
                        ImagePlus imp = plot.getImagePlus();
                        imp.setTitle(title);
                        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + title + ".tif");
                        //save Rm value
                        double[] RmAndTheta = (double[]) result.get(0);
                        mouseData.put(resultName + "_RmPlot", (float) RmAndTheta[0]);
                        trialData.set(mouse, mouseData);
                    } catch (NullPointerException e) {
                        if (DispDt == null) {
                            taskLog += "R-Distance needs to be calculated.\n";
//                            JOptionPane.showMessageDialog(frame, "R-Distance must be calculated to proceed.\n" + taskLog, "ERROR", JOptionPane.ERROR_MESSAGE);
                            System.out.println(taskLog);
                            System.out.println(e);
                            return;
                        } else {
                            taskLog += "R-" + resultName + " must be calculated for" + title + "plot.\n";
                            System.out.println(taskLog);
                            System.out.println(e);
                        }
                    } catch (Exception e) {
                        taskLog += "Error occured while generating " + title + " plots.\n";
                        System.out.println(taskLog);
                        System.out.println(e);
                    }
                }

                //average mice
                if (jCheckBoxAverageMousePlot.isSelected()) {
                    DataTrace_ver1 aveDispDt = new DataTrace_ver1();
                    DataTrace_ver1 aveResultDt = new DataTrace_ver1();
                    String title = "Distance vs R" + resultName + "_AveM";
                    //loop through mice
                    DataTrace_ver1 DispDt = null, resultDt = null;
                    try {
                        for (int mouse = 0; mouse < dss.getTotalMice(); mouse++) {
                            HashMap<String, Object> mouseData = trialData.get(mouse);
                            DispDt = (DataTrace_ver1) mouseData.get("Displacement");
                            resultDt = (DataTrace_ver1) mouseData.get(resultName);
                            aveDispDt.addAll(DispDt);
                            aveResultDt.addAll(resultDt);
                        }
                    } catch (NullPointerException e) {
                        System.out.println("Exception " + e);
                        if (DispDt == null) {
                            taskLog += "R-Distance needs to be calculated.\n";
//                          JOptionPane.showMessageDialog(frame, "R-Distance must be calculated to proceed.\n" + taskLog, "ERROR", JOptionPane.ERROR_MESSAGE);
                            return;
                        } else {
//                            JOptionPane.showMessageDialog(frame, "R-" + resultName + " must be calculated for" + title + " plot.", "ERROR", JOptionPane.ERROR_MESSAGE);
                            taskLog += "R-" + resultName + " must be calculated for" + title + "plot.\n";
                        }
                    } catch (Exception e) {
                        System.out.println("Exception " + e);
                        taskLog += "Error occured while generating " + title + " plots.\n";
                    }

                    try {
                        //calculate r-distance and r-measure
                        ArrayList<Object> result = this.RmFromPolynomialFit(aveDispDt, aveResultDt);
                        //decorate and save plot
                        Plot plot = (Plot) result.get(1);
                        plot.setXYLabels("Distance", resultName);
                        //PlotWindow pw = plot.show();
                        //pw.setTitle(title);
                        ImagePlus imp = plot.getImagePlus();
                        imp.setTitle(title);
                        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + title + ".tif");
                        //save Rm value
                        double[] RmAndTheta = (double[]) result.get(0);
                        HashMap<String, Object> mouseData = trialData.get(dss.getTotalMice());
                        mouseData.put(resultName + "_RmPlot", (float) RmAndTheta[0]);
                        trialData.set(dss.getTotalMice(), mouseData);
                    } catch (Exception e) {
                        System.out.println("Exception " + e);
                        taskLog += "Error occured while generating " + title + " plots.\n";
                    }
                }
            }
            try {
                dss.writeFile(resultName, "RmPlot", "", Rm);
            } catch (Exception e) {
                System.out.println("Exception " + e);
                taskLog += "Error occured while writing Rm values into a file.\n";
            }
            if (i == Integer.MAX_VALUE) {
                break;
            }
        }

        if (!taskLog.isEmpty()) {
            JOptionPane.showMessageDialog(frame, "Task completed with the following errors:\n" + taskLog, "Task Completed with Error.", JOptionPane.WARNING_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(frame, "Task completed.\n" + taskLog, "Task Completed", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_jButtonGeneratePlotsActionPerformed

    /**
     * Calculate vector magnitude i.e. r
     */
    private ArrayList<Double> vectorMagnitude(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            result.add(i, (Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))));
        }
        return result;
    }

    /**
     * Calculate vector angle i.e. theta
     */
    private ArrayList<Double> vectorAngle(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            if (x != 0) {
                result.add(i, Math.atan2(y, x)); //How to deal with x=0 error?
            } else {
                result.add(i, Double.MAX_VALUE);
            }
        }
        return result;
    }

    /**
     * Calculate (x(i+1) - x(i), y(i+1) - y(i))
     */
    private DataTrace_ver1 getSuccessiveDifference(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        for (int i = 0; i < (series.size() - 1); i++) {
            double x1 = series.get(i).getX().doubleValue();
            double x2 = series.get(i + 1).getX().doubleValue();
            double y1 = series.get(i).getY().doubleValue();
            double y2 = series.get(i + 1).getY().doubleValue();
            result.addData((x2 - x1), (y2 - y1));
        }
        return result;
    }

    /**
     * Calculate residence time
     */
    private ArrayList<Double> residenceTime(DataTrace_ver1 series) {
        ArrayList<Double> resTime = new ArrayList();
        for (int count = 0; count < (dimX * dimY); count++) {
            resTime.add(0d);
        }
        for (int i = 0; i < series.size(); i++) {
            double XPo = series.get(i).getX().doubleValue();
            double YPo = series.get(i).getY().doubleValue();
            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            resTime.set(arrayIdx, (resTime.get(arrayIdx) + 1));
        }
        return resTime;
    }

    /**
     * calculate displacement vector from the platform location
     */
    private DataTrace_ver1 displacementVector(DataTrace_ver1 series) {
        DataTrace_ver1 seriesCorr = new DataTrace_ver1();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            seriesCorr.addData((pX - x), (pY - y));
        }
        return seriesCorr;
    }

    /**
     * calculate velocity vector from the platform location
     */
    private DataTrace_ver1 velocityVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 displacement = this.displacementVector(series);
        //delvel                        
        result = this.getSuccessiveDifference(displacement);
        return result;
    }

    /**
     * calculate velocity components along and perpendicular to platform
     */
    private DataTrace_ver1 velocityComponents(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 velocityVector = this.velocityVector(series);
        ArrayList<Double> RVel = this.vectorMagnitude(velocityVector);
        ArrayList<Double> ThetaVel = new ArrayList<>();
        //Calculate ThetaVel and RVelaP
        for (int k = 0; k < (series.size() - 1); k++) {
            double delVel_x = velocityVector.get(k).getX().doubleValue();
            double delVel_y = velocityVector.get(k).getY().doubleValue();
            double seriesCorr_x = displacementVector.get(k).getX().doubleValue();
            double seriesCorr_y = displacementVector.get(k).getY().doubleValue();
            double value = ((delVel_x * seriesCorr_x) + (delVel_y * seriesCorr_y)) / (RDist.get(k) * RVel.get(k));
            ThetaVel.add(k, Math.acos(value));
            double xvalue = RVel.get(k) * Math.cos(ThetaVel.get(k));
            double yvalue = RVel.get(k) * Math.sin(ThetaVel.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components along platform
     */
    private DataTrace_ver1 velocityAlongPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getX().get(k) * Math.cos(theta.get(k));
            double yvalue = (double) velocityComponents.getX().get(k) * Math.sin(theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components perpendicular to platform
     */
    private DataTrace_ver1 velocityPerpendicularPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getY().get(k) * Math.cos(90 + theta.get(k));
            double yvalue = (double) velocityComponents.getY().get(k) * Math.sin(90 + theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate velocity error vectors
     */
    private DataTrace_ver1 velocityErrorVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 velocityVector = this.velocityVector(series);
        DataTrace_ver1 RVel = this.displacementVector(series);

        for (int k = 0; k < (series.size() - 1); k++) {
            //calculate unit vector
            double cap_x = displacementVector.get(k).getX().doubleValue();
            double cap_y = displacementVector.get(k).getY().doubleValue();
            //velocity vector along platform
            double velValueX = velocityVector.get(k).getX().doubleValue();
            double velValueY = velocityVector.get(k).getY().doubleValue();
            //calculate difference between velocity vector along pt and velocity vector i.e. vel error vector
            result.addData(((velValueX * cap_x) - velValueX), ((velValueY * cap_y) - velValueY));
        }
        return result;
    }

//    /**
//     * save heat map
//     */
//    private void saveHeatMap(String title, ImagePlus imp) {
//        //ImagePlus imp = new ImagePlus(title, ip);
//        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + imp.getTitle() + ".tif");
//    }
    /**
     * calculate each pixel value given xy data points in DataTrace_ver1
     */
    private ImageProcessor sumPixelsImage(DataTrace_ver1 curSeries, ArrayList<Double> M) {
        ImagePlus image = new ImagePlus();
        ImageProcessor ip = new FloatProcessor(dimX, dimY);
        float[][] ipArray = ip.getFloatArray();

        int size = M.size();
        for (int j = 0; j < size; j++) {
            double XPo = curSeries.get(j).getX().doubleValue();
            double YPo = curSeries.get(j).getY().doubleValue();
//            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            int xPix = (int) Math.round(XPo);
            int yPix = (int) Math.round(YPo);
//            array.set(arrayIdx, (array.get(arrayIdx) + M.get(j)));
            ipArray[xPix][yPix] = (float) (ipArray[xPix][yPix] + M.get(j));
            //NOTE: CANNOT USE NANs WHEN USING SurfaceFit/Differentials plugin
            //Make NaN image during resize for div,curl,grad. Use ipResROI for heat map
        }
        ip.setFloatArray(ipArray);
//        image.setProcessor(ip);
        return ip;
    }

    /**
     * generate residence time weighted heat map
     */
    private ImagePlus resTimeWeightedMap(ImageProcessor resTimeMap, ImageProcessor measureMap) {
        ImagePlus imagePlus = new ImagePlus();
        ImageProcessor ip = new FloatProcessor(dimX, dimY);
        float[][] resTime = resTimeMap.getFloatArray();
        float[][] measure = measureMap.getFloatArray();

        float[][] image = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                if (resTime[X][Y] != 0) {
                    image[X][Y] = (float) (measure[X][Y] / resTime[X][Y]);
                } else {
                    image[X][Y] = 0f;
                }
            }
        }
        ip.setFloatArray(image);

        //Save resTimeROI on imagePlus of measure
        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = resTimeMap.getMax();
        resTimeMap.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(resTimeMap);
        //ip.setRoi(selectionROI);
        imagePlus.setProcessor(ip);
        imagePlus.setRoi(selectionROI);
        return imagePlus;
    }

    /**
     * generate vector map
     */
    private ImagePlus vectorMap(ImagePlus xImage, ImagePlus yImage, String resultName) {
        ImagePlus result = null;
//        float[][] xFloatArray = xImage.getProcessor().getFloatArray();
//        float[][] yFloatArray = yImage.getProcessor().getFloatArray();
        ImageProcessor xImg = xImage.getProcessor();
        ImageProcessor yImg = yImage.getProcessor();

        double[] xBegin = new double[dimX * dimY];
        double[] yBegin = new double[dimX * dimY];
        double[] xEnd = new double[dimX * dimY];
        double[] yEnd = new double[dimX * dimY];

        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                int arrayIdx = (Y * dimX) + X;
                float xPixelValue = xImg.getPixelValue(X, Y);
                float yPixelValue = yImg.getPixelValue(X, Y);
                if (xPixelValue != 0 && yPixelValue != 0) {
                    xBegin[arrayIdx] = X;
                    yBegin[arrayIdx] = Y;
                    xEnd[arrayIdx] = xPixelValue + X;
                    yEnd[arrayIdx] = yPixelValue + Y;
                }
            }
        }
        Plot vectorMap = new Plot(resultName + " vector plot", "X Axis", "Y Axis");
        vectorMap.setLimits(0, dimX, 0, dimY);
        vectorMap.drawVectors(xBegin, yBegin, xEnd, yEnd);
//        vectorMap.show();
        result = vectorMap.getImagePlus();
        return result;
    }

    /**
     * generate polynomial surface fit of order 3
     */
    private ImagePlus thresholdedSurfaceFit3(ImagePlus image) {

//    private ImagePlus thresholdedSurfaceFit3(ImageProcessor ipResTime, ImagePlus image) {
// TO DO - Utilise ROI saved in image.getProcessor. Eliminates ipResTime as an input       
//        //threshold out 0 values and create an ROI in restime image
//        double minValue = 1;
//        double maxValue = ipResTime.getMax();
////        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
//        ipResTime.setThreshold(minValue, maxValue, 3);
//        ThresholdToSelection tts = new ThresholdToSelection();
//        Roi selectionROI = tts.convert(ipResTime);
////        Rectangle bounds = selectionROI.getBounds();
////        System.out.println("Bounding rect" + bounds);
//        image.setRoi(selectionROI);
        //polynomial fit function -
        Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
//        image.show();
        image = psf.run(image.getProcessor());
//        image.show();
        return image;
    }

    /**
     * generate divergence
     */
    private ImagePlus divergence(ImagePlus xImage, ImagePlus yImage) {

        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(xImage, 6); //differentiate wrt x        
        diffJB.run2(yImage, 7); //differentiate wrt y
        //add images
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.ADD);
        return yImage;
    }

    /**
     * generate curl
     */
    private ImagePlus curl(ImagePlus xImage, ImagePlus yImage) {

        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(yImage, 6); //differentiate wrt x
        diffJB.run2(xImage, 7); //differentiate wrt y        
        //subtract images
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.DIFFERENCE);
        return yImage;
    }

    /**
     * generate gradient
     */
    private ImagePlus gradient(ImagePlus image) {

        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(image, 0); //gradient magnitude
        return image;
    }

    /**
     * calculates Rm value from vector/scalar property map
     */
    private double[] RmFromMap(ImageProcessor ipResTime, ImageProcessor ip) {
        double[] RmArray = new double[2];
        //threshold out 0 values and create an ROI using restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//      System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();
//      System.out.println("Bounding rect" + bounds);

        //Find coordinates within the pool ROI
        OvalRoi pool = new OvalRoi(0, 0, 240, 240);
        MaximumFinder mf = new MaximumFinder();

        //find coordinates of maxima and minima points
        Polygon[] pixelList = new Polygon[2];
        Polygon points = mf.getMaxima(ip, 0.00001, true); //excludes edges
        pixelList[0] = points;
        ip.invert();
        points = mf.getMaxima(ip, 0.00001, true); //excludes edges
        pixelList[1] = points;
        for (int i = 0; i < pixelList.length; i++) {
            ArrayList<Double> RmList = new ArrayList<>();
            ArrayList<Float> intensity = new ArrayList<>();
            int xb = (int) bounds.getX();
            int yb = (int) bounds.getY();
            Polygon pixel = pixelList[i];
            for (int ii = 0; ii < pixel.npoints; ii++) {
                int X = pixel.xpoints[ii] + xb;
                int Y = pixel.ypoints[ii] + yb;
                if (pool.containsPoint(X, Y)) {
                    intensity.add(ip.getPixelValue(pixel.xpoints[ii], pixel.ypoints[ii]));
                    double Rm = Math.sqrt(Math.pow((pX - X), 2) + Math.pow((pY - Y), 2));
                    RmList.add(Rm);
                }
            }
            double Rm;
            try {
                float max_intensity = Collections.max(intensity);
                int index = intensity.indexOf(max_intensity);
                Rm = RmList.get(index);
            } catch (NoSuchElementException c) {
                Rm = Double.NaN;
            }
            RmArray[i] = Rm;
        }
//        System.out.println(Arrays.toString(RmArray));
        return RmArray;
    }

    /**
     * resize surface fit-differential images to dimX by dimY dimensions
     */
    private ImagePlus resizeImage(ImageProcessor ipResTime, ImageProcessor ip) {
        ImagePlus imp = new ImagePlus();
        OvalRoi pool = new OvalRoi(0, 0, 240, 240);

        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();

//      resize image to 240 by 240 dimension
        float[][] processedArray = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                processedArray[X][Y] = Float.NaN;
//                processedArray[X][Y] = 0;
            }
        }
        int xb = (int) bounds.getX();  //already defined above
        int yb = (int) bounds.getY();  // already defined above
        int xbmax = (int) bounds.getWidth();
        int ybmax = (int) bounds.getHeight();
        float[][] f = ip.getFloatArray();
        for (int Y = 0; Y < ybmax; Y++) {
            for (int X = 0; X < xbmax; X++) {
                if (pool.containsPoint(X + xb, Y + yb)) {
                    processedArray[X + xb][Y + yb] = f[X][Y];
                }
            }
        }
        ImageProcessor processedip = new FloatProcessor(processedArray);
        imp.setProcessor(processedip);
        return imp;
    }

    /**
     * get mean pixel intensity of quadrants and zones
     */
    private float[] quadrantandZoneMeasures(ImagePlus imp) {
        float[] mean = new float[8];
        int Px = pX;
        int Py = pY;

        int iWidth = (int) dimX / 2;
        int iHeight = (int) dimY / 2;
        int iXROI = 0;
        int iYROI = 0;
        Roi[] quadROIs = new Roi[4];
        quadROIs[0] = new Roi(iXROI, iYROI, iWidth, iHeight);
        quadROIs[1] = new Roi(iXROI + iWidth, iYROI, iWidth, iHeight);
        quadROIs[2] = new Roi(iXROI + iWidth, iYROI + iHeight, iWidth, iHeight);
        quadROIs[3] = new Roi(iXROI, iYROI + iHeight, iWidth, iHeight);
        RoiManager roiMan = new RoiManager(false);
        int quadNo = -1;
        for (int i = 0; i < quadROIs.length; i++) {
            Roi quad = quadROIs[i];
            roiMan.addRoi(quad);
            boolean platQuad = quad.contains(Px, Py);
            if (platQuad) {
                quadNo = i;
            }
        }
        OvalRoi[] zoneROIs = new OvalRoi[4];
        iWidth = 20;
        iHeight = 20;
        int x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0;
        switch (quadNo) {
            //quadrants labelled from 0 to 3 in clockwise direction
            case 0: //quad 0
                x0 = Px - (iWidth / 2);
                y0 = Py - (iHeight / 2);
                x1 = x0 + (dimX / 2);
                y1 = y0;
                x2 = x1;
                y2 = y0 + (dimY / 2);
                x3 = x0;
                y3 = y2;
                break;
            case 1: //quad 1
                x1 = Px - (iWidth / 2);
                y1 = Py - (iHeight / 2);
                x0 = x1 - (dimX / 2);
                y0 = y1;
                x2 = x1;
                y2 = y1 + (dimY / 2);
                x3 = x0;
                y3 = y2;
                break;
            case 2: //quad 2
                x2 = Px - (iWidth / 2);
                y2 = Py - (iHeight / 2);
                x0 = x2 - (dimX / 2);
                y0 = y2 - (dimY / 2);
                x1 = x2;
                y1 = y0;
                x3 = x0;
                y3 = y2;
                break;
            case 3: //quad 3
                x3 = Px - (iWidth / 2);
                y3 = Py - (iHeight / 2);
                x0 = x3;
                y0 = y3 - (dimY / 2);
                x1 = x3 - (dimX / 2);
                y1 = y0;
                x2 = x1;
                y2 = y3;
                break;
            default:
                System.out.println("Platform coordinates are not within pool dimensions");
                break;
        }
        zoneROIs[0] = new OvalRoi(x0, y0, iWidth, iHeight);
        zoneROIs[1] = new OvalRoi(x1, y1, iWidth, iHeight);
        zoneROIs[2] = new OvalRoi(x2, y2, iWidth, iHeight);
        zoneROIs[3] = new OvalRoi(x3, y3, iWidth, iHeight);
        for (OvalRoi zone : zoneROIs) {
            roiMan.addRoi(zone);
        }
        //set mean measurement, multimeasure using 8 rois in roimanager, get results table
        Analyzer.setMeasurements(Measurements.MEAN);
        ResultsTable rt = roiMan.multiMeasure(imp);
//        rt.show("");

        //print out result table values
        for (int row = 0; row < rt.size(); row++) {
            for (int col = 0; col < roiMan.getCount(); col++) {
//                System.out.println(row + " " + col + " " + rt.getValueAsDouble(col, 0));
                mean[col] = (float) rt.getValueAsDouble(col, row);
            }
        }
//        System.out.println(Arrays.toString(mean));
        return mean;
    }

    /**
     * calculates Rm value from polynomial fit of distance vs r-measure
     */
    private ArrayList<Object> RmFromPolynomialFit(DataTrace_ver1 DispDt, DataTrace_ver1 resultDt) {
        ArrayList<Object> output = new ArrayList<>();
        //calculate r-distance and r-measure
        ArrayList<Double> dist = this.vectorMagnitude(DispDt);
        ArrayList<Double> result = this.vectorMagnitude(resultDt);
        //add x,y data to datatrace for binning
        DataTrace_ver1 distVmeasure = new DataTrace_ver1();
        for (int j = 0; j < dist.size() && j < result.size(); j++) {
            distVmeasure.addData(dist.get(j), result.get(j));
        }
        //binInX and DO NOT restore original order
        distVmeasure = distVmeasure.binData(userBin, true, false);

        //1st: fit to polynomial, get parameters of fit and plot
        //convert dataTrace's arraylist<Double> to double[]
        ArrayList<Double> dbl = (ArrayList<Double>) distVmeasure.getX();
        double[] xData = dbl.stream()
                .mapToDouble(Double::doubleValue)
                .toArray();
        dbl = (ArrayList<Double>) distVmeasure.getY();
        double[] yData = dbl.stream()
                .mapToDouble(Double::doubleValue)
                .toArray();
        CurveFitter cf = new CurveFitter(xData, yData);
        cf.doFit(CurveFitter.POLY2);
        double[] para = cf.getParams();
        Plot plot = cf.getPlot();

//        //2nd: save decorate plot and save plot
//        plot.setXYLabels("Distance", resultName);
//        String title = "Dist vs R" + resultName + "_M" + mouse;
//                        PlotWindow pw = plot.show();
//                        pw.setTitle(title);
//        ImagePlus imp = plot.getImagePlus();
//        imp.setTitle(title);
//        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + title + ".tif");
        //3rd: calculate Rm from fit parameters
        double B0 = para[0];
        double B1 = para[1];
        double B2 = para[2];
        double[] Rm = new double[3];
        double det = 48.10488 + (72 * B1);
        double thetam1 = (9.42 + Math.sqrt(det)) / 6;
        double thetam2 = (9.42 - Math.sqrt(det)) / 6;
        double RmValue = (Math.pow(thetam1, 2) - (3.14 * thetam1) + 3.287) / (2 * (B2 + 1));
        Rm[0] = RmValue;
        Rm[1] = thetam1;
        Rm[2] = thetam2;

        output.add(Rm);
        output.add(plot);

        return output;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new WMSoftwareGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupPlotGroupDataBy;
    private javax.swing.JButton jButtonCalculateMeasures;
    private javax.swing.JButton jButtonGenerateMaps;
    private javax.swing.JButton jButtonGeneratePlots;
    private javax.swing.JButton jButtonReadFiles;
    private javax.swing.JButton jButtonSelectFiles;
    private javax.swing.JButton jButtonUploadFiles;
    private javax.swing.JCheckBox jCheckBoxASCIIvector;
    private javax.swing.JCheckBox jCheckBoxAverageMouseMap;
    private javax.swing.JCheckBox jCheckBoxAverageMousePlot;
    private javax.swing.JCheckBox jCheckBoxCurl;
    private javax.swing.JCheckBox jCheckBoxDivergence;
    private javax.swing.JCheckBox jCheckBoxGradient;
    private javax.swing.JCheckBox jCheckBoxHeatMap;
    private javax.swing.JCheckBox jCheckBoxRDist;
    private javax.swing.JCheckBox jCheckBoxRDistvRVel;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelErr;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelaP;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelpP;
    private javax.swing.JCheckBox jCheckBoxRVel;
    private javax.swing.JCheckBox jCheckBoxRVelErr;
    private javax.swing.JCheckBox jCheckBoxRVelaP;
    private javax.swing.JCheckBox jCheckBoxRVelpP;
    private javax.swing.JCheckBox jCheckBoxResTime;
    private javax.swing.JComboBox<String> jComboBoxTrialNo;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabelMaps;
    private javax.swing.JLabel jLabelMaps1;
    private javax.swing.JLabel jLabelPlots;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JProgressBar jProgressBar;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextField jTextFieldTotalMiceNo;
    private javax.swing.JTextField jTextFieldTrials;
    private javax.swing.JTextField jTextFieldUserBin;
    // End of variables declaration//GEN-END:variables
}
